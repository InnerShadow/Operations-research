---
title: Лабораторная работа 3. Задания
author: "Автор"
date: "10/02/2024"
output:
  html_document:
    df_print: paged
    keep_md: true
  word_document: default
  pdf_document:
    latex_engine: lualatex
    includes:
      in_header: preamble.tex
editor_options: 
  markdown: 
    wrap: sentence
---

# Задача

Рассмотрим телекоммуникационную сеть, состоящую из $p$ узлов-маршрутизаторов $R$ и $q$ соединяющих их линий связи $P$.
Каждая линия связи оценивается временем задержки сигнала измеряемым в миллисекундах: $$W=\{w_1,w_2,...,w_q\}$$ Маршрутизаторы, имеют горячее резервирование кратности: $$SR=\{sr_1,sr_2,...,sr_p\}\\ 1\leq sr_i\leq 5$$ Линии связи имеют дублирование кратности: $$SP=\{sp_1,sp_2,...,sp_q\}\\ 1\leq sp_i\leq 5$$ Для высококритичных приложений, например, для военной техники, обязателен резерв канала боевого управления, а скорость передачи данных оказывает существенное влияние на отклик системы в целом.
Требуется найти два (в общем случае можно рассматривать $r$) зарезервированных канала от узла $k$ к узлу $l$, не задействующих совместно незадублированные маршрутизаторы и линии связи, обеспечивающих суммарно минимальное время задержки.

# Указания к решению.

1.  Найти все $N$ не образующие петель маршруты $Rt$ от узла $k$ к узлу $l$.
    Это можно сделать вручную.
    На высокую оценку необходимо разработать и реализовать алгоритм, осуществляющий построение таких маршрутов.
    Допускается использование библиотечной функции.

2.  Занумеруем все возможные маршруты от $1$ до $n$ и сопоставим каждому из них соответствующее время задержки $t_i$, равное сумме времен по всем ребрам маршрута $i$.

3.  Введем в качестве варьируемых параметров бинарные переменные $x_i$, $i=1,...,n$.
    Здесь $x_i=1$, если маршрут номер $i$ выбран и $x_i=0$, если нет.
    Тогда целевая функция, которую необходимо минимизировать, будет иметь вид: $$F(\vec{x})=\sum_{i=1}^{N}t_ix_i\\$$ Так как необходимо найти $r$ независимых каналов, первое ограничение имеет вид (в простейшем случае для двукратного резервирования $r=2$): $$\sum_{i=1}^{N}x_i=r$$

4.  Далее требуется построить ограничение ресурсов для маршрутов.
    Столбцами матрыцы ограничений будут маршруты, а по строкам задействованные маршрутизаторы и линии связи.
    Следовательно, для всех маршрутов использующих совместно маршрутизатор (линию связи) можно записать ограничение: $$\sum_{i\in V(Rt)} x_i \leq SR\\ \sum_{i\in E(Rt)} x_i \leq SP$$

    В теории графов для графа $g$ множество его вершин обозначается как $V(g)$, а множество его рёбер $E(g)$.

5.  Решаем задачу линейного целочисленного программирования.

6.  Построить граф с выделенными найденными маршрутами.

# Варианты

Введите ваше ФИО в параметр функции **digest2int**


```r
# install.packages('extraDistr')

library(digest)
library(extraDistr)
set.seed(digest2int('Сиколенко Михаил Александрович'))
```

Переменная *simple* отвечает за выбор варианта сложности.


```r
simple <- T
```

Далее на основании вашего ФИО и варианта сложности генерируются основные параметры задачи.
Число маршрутизаторов $p$:


```r
p <- ifelse(simple, rdunif(1,6,10), rdunif(1,25,50))
p
```

```
## [1] 10
```

Число резервных маршрутов $r$


```r
r <- ifelse(simple,2,rdunif(1,3,5))
r
```

```
## [1] 2
```

Граф маршрутизации


```r
library(igraph)

repeat
{
g <<- sample_gnp(p, ifelse(simple,0.2,0.05))
if(is_connected(g))
  break
}
```

Количество линий связи $q$


```r
q <- length(E(g))
q
```

```
## [1] 10
```

Задержка линии связи $W$


```r
E(g)$weight <- rdunif(q,1,100)
```

Резервирование маршрутизаторов $SR$


```r
V(g)$standby <- if(simple) rep(2,p) else rdunif(p,r,5)
```

Резервирование линий связи $SP$


```r
E(g)$standby <- if(simple) rep(2,q) else rdunif(q,r,5)
```

Узлы, между которыми требуется обеспечить надежную связь


```r
v <- farthest_vertices(g)$vertices
v
```

```
## + 2/10 vertices, from 2152b8a:
## [1] 2 4
```

```r
k <- v[1]
l <- v[2]
```

# Ваш вариант



Общая формулировка задачи выглядит следующим образом **(подстановка реализуется при сохранении, например html)**:

Рассмотрим телекоммуникационную сеть, состоящую из $p=10$ узлов-маршрутизаторов $R$ и $q=10$ соединяющих их линий связи $P$.
Сеть определяется граформ, заданным списком смежности: $$
\newcommand\ue{\mathrel{\bullet\mkern-3mu{-}\mkern-3mu\bullet}}
\{1\ue4,3\ue5,5\ue7,6\ue7,1\ue8,6\ue8,5\ue9,2\ue10,8\ue10,9\ue10\}
$$ Каждая линия связи оценивается временем задержки сигнала измеряемым в миллисекундах: $$W=\{38,52,8,38,90,60,25,82,78,25\}$$ Маршрутизаторы, имеют горячее резервирование кратности: $$SR=\{2\}$$ Линии связи имеют дублирование кратности: $$SP=\{2\}$$ Требуется найти $r=2$ зарезервированных канала от узла $k=2$ к узлу $l=4$, не задействующих совместно незадублированные маршрутизаторы и линии связи, обеспечивающих суммарно минимальное время задержки.

![](Lab3Task_files/figure-html/unnamed-chunk-12-1.png)<!-- -->



```r
edge_list <- as_edgelist(g)
print(edge_list)
```

```
##       [,1] [,2]
##  [1,]    1    4
##  [2,]    3    5
##  [3,]    5    7
##  [4,]    6    7
##  [5,]    1    8
##  [6,]    6    8
##  [7,]    5    9
##  [8,]    2   10
##  [9,]    8   10
## [10,]    9   10
```



```r
W <- E(g)$weight
W
```

```
##  [1] 38 52  8 38 90 60 25 82 78 25
```



```r
filter_loops <- function(paths) {
  filtered_paths <- lapply(paths, function(path) {
    if (!anyDuplicated(path)) {
      return(path)
    }
    return(NULL)
  })
  return(filtered_paths[!sapply(filtered_paths, is.null)])
}

find_non_loop_paths <- function(g, k, l) {
  all_paths <- all_simple_paths(g, from = k, to = l)
  non_loop_paths <- filter_loops(all_paths)
  return(non_loop_paths)
}
```



```r
non_loop_paths <- find_non_loop_paths(g, k, l)
print(non_loop_paths)
```

```
## [[1]]
## + 5/10 vertices, from 2152b8a:
## [1]  2 10  8  1  4
## 
## [[2]]
## + 9/10 vertices, from 2152b8a:
## [1]  2 10  9  5  7  6  8  1  4
```









# Оценивание

4-6 Поиск маршрутов вручную, задание ограничений вручную, простой вариант.

6-8 Автоматический поиск маршрутов, автоматическое или ручное задание ограничений, простой вариант.

8-10 Автоматическое решение общей задачи, отсутсвие явных циклов (используйте функции \*apply), продвинутая индексация.
